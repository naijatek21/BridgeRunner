<!DOCTYPE html>
<html>
<h1>Welcome to Bridge Hikers</h1>
<button class="main" style="position: absolute; size: 200px;"> Random input</button>
<button class="main" style="position: fixed; size: 200px; right: 0;"> Custom input</button>
<div id="">
  <input> <input type="text">
  <input type="submit" value="Submit">
</div>

</html>
<style>
</style>

<script>
  // Creates a set of 1 to 50 Bridges speeds up to 100 ft/min.
  function generateRandomHikers() {
    var hikerGroup = new maxHeap();
    h = [];
    var hSize = Math.ceil(Math.random() * 50);
    for (i = 0; i < rlength; i++) {
      h.add(new Hiker("H" + i, Math.ceil(Math.random() * 100)));
    }
    hikerGroup.buildHeap(h);
    return hikerGroup;
  }

  // Creates a set of 1 to 100 random bridges with lengths up to 300 ft. 
  function generateRandomBridges() {
    var bridges = [];
    var rlength = Math.ceil(Math.random() * 100);
    for (i = 0; i < rlength; i++) {
      bridges.add(new Bridge("B" + i, Math.ceil(Math.random() * 300)));
    }
    return bridges;

  }
  function generateHikers() {

  }
  function generateBridges() { }

  function getBridgeTime(hikers, bridges) {
    var torchbearer = hikers.removeMax();
    var currentBridge = bridges.head;
    var timeTotal;
    currentBridge.addHiker(torchbearer);
    hikers.forEach(hiker => {
      crossingTime = (bridge.length / hiker.speed);
      currentBridge.addHiker(hiker);
      if (bridges.next.pickup() != null) {
        if (bridges.next.newHiker.speed > torchbearer.speed)
          torchbearer = bridges.next.newHiker
      }
      crossingTime += (bridge.length / tourchbearer.speed);
      timeTotal += crossingTime;
    });
    print(bridge.report());
    return timeTotal;
  }





  class Bridge {
    Bridge(name, length) {
      this.length = length;
      hikers = 0;
      ledger = [];
      this.name = name;
      newHiker = null;

      this.report = function () {
        return "Bridge " + this.name + "of length " + this.length + "ft. was crossed by /n"
          + ((this.ledger.toArray()).toString()) + "/n" + "with a total of " + this.hikers + "hikers";
      }

    }

    Bridge(name, length, hiker) {
      this.length = length;
      hikers = 0;
      ledger = [];
      this.name = name;
      newHiker = h;

      this.report = function () {
        return "Bridge " + this.name + "of length " + this.length + "ft. was crossed by /n"
          + ((this.ledger.toArray()).toString()) + "/n" + "with a total of " + this.hikers + "hikers";
      }

    }


    addHiker = function (hiker) {
      ledger.add(hiker.getId());
      this.hikers += 1;
    }


    pickup = function () {
      h = this.newHiker;
      this.newHiker = null;
      return h;
    }


  }



  class ListNode {
    constructor(data) {
      this.data = data
      this.next = null
    }
  }
  class LinkedList {
    constructor(head = null) {
      this.head = head
    }
  }


  class maxHeap {
    constructor() {
      this.heap = [];
    }
    insert(val) {
      //create a new child at the end of the heap
      this.heap.push(val);
      let index = this.heap.length - 1;
      this.__bubbleUp(index);
    }
    /**
     * This function returns the maximum value in the heap which is the root, i.e., the first value in the array. It does not modify the heap itself. The time complexity of this function is in O(1) constant time.
     */
    getMax() {
      if (this.heap.length != 0) return this.heap[0];
      return null;
    }
    /**
     * This function removes and returns the maximum value in the heap. The time complexity of this function is in O(log(n)) because that is the maximum number of nodes that would have to be traversed and/or swapped.
     */
    removeMax() {
      if (this.heap.length > 1) {
        let max = this.heap[0];
        // move the last child node to root
        this.heap[0] = this.heap.pop();
        this.__maxHeapify(0);
        return max;
      } else if (this.heap.length === 1) {
        return this.heap.pop();
      } else return null;
    }

    __maxHeapify(index) {
      while (true) {
        let leftChild = (index * 2) + 1;
        let rightChild = leftChild + 1;
        let largest = index;
        if (this.heap.length > leftChild && (this.heap[largest]).speed < (this.heap[leftChild].speed)) largest = leftChild;
        if (this.heap.length > rightChild && (this.heap[largest]).speed < (this.heap[rightChild]).speed) largest = rightChild;
        if (largest !== index) {
          let temp = this.heap[largest];
          this.heap[largest] = this.heap[index];
          this.heap[index] = temp;
          this.__maxHeapify(largest);
        } else break;
      }

    }
    /**
     * This function restores heap property by swapping the value at a parent node if it is less than the value at a child node. The time complexity of this function is in O(log(n)) because that is the maximum number of nodes that would have to be traversed and/or swapped.
     */
    __bubbleUp(index) {
      const element = this.heap[index];
      while (index > 0) {
        let parentIndex = Math.floor((index - 1) / 2);
        let parent = this.heap[parentIndex];
        if (parent.speed <= element.speed) {
          this.heap[parentIndex] = element;
          this.heap[index] = parent;
          index = parentIndex;
        } else break;
      }
    }

    /**
     * Letâ€™s build a max-heap now. Suppose we have nn elements in an array which represents our heap. For every node to be positioned in accordance with the max-heap property, we call the _maxHeapify method at every index of that array, starting from the bottom of the heap
     */
    buildHeap(arr) {
      this.heap = arr;
      for (let i = this.heap.length - 1; i >= 0; i--) {
        this.__maxHeapify(i);
      }
    }
  }

// var tree = new maxHeap()
// var arr = [6, 9, 3, 4, 13, 22, 1, 30, 17]
// tree.buildHeap(arr)
// console.log(tree.heap)
// tree.removeMax();
// console.log(tree.getMax())
// console.log(tree.heap);


</script>